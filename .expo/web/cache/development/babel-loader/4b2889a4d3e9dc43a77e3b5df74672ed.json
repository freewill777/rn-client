{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TabBarItem from \"./TabBarItem\";\nimport TabBarIndicator from \"./TabBarIndicator\";\nimport useAnimatedValue from \"./useAnimatedValue\";\nvar Separator = function Separator(_ref) {\n  var width = _ref.width;\n  return React.createElement(View, {\n    style: {\n      width: width\n    }\n  });\n};\nvar getFlattenedTabWidth = function getFlattenedTabWidth(style) {\n  var tabStyle = StyleSheet.flatten(style);\n  return tabStyle === null || tabStyle === void 0 ? void 0 : tabStyle.width;\n};\nvar getComputedTabWidth = function getComputedTabWidth(index, layout, routes, scrollEnabled, tabWidths, flattenedWidth) {\n  if (flattenedWidth === 'auto') {\n    return tabWidths[routes[index].key] || 0;\n  }\n  switch (typeof flattenedWidth) {\n    case 'number':\n      return flattenedWidth;\n    case 'string':\n      if (flattenedWidth.endsWith('%')) {\n        var width = parseFloat(flattenedWidth);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n  if (scrollEnabled) {\n    return layout.width / 5 * 2;\n  }\n  return layout.width / routes.length;\n};\nvar getMaxScrollDistance = function getMaxScrollDistance(tabBarWidth, layoutWidth) {\n  return tabBarWidth - layoutWidth;\n};\nvar getTranslateX = function getTranslateX(scrollAmount, maxScrollDistance) {\n  return Animated.multiply(Platform.OS === 'android' && I18nManager.isRTL ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1)) : scrollAmount, I18nManager.isRTL ? 1 : -1);\n};\nvar getTabBarWidth = function getTabBarWidth(_ref2) {\n  var navigationState = _ref2.navigationState,\n    layout = _ref2.layout,\n    gap = _ref2.gap,\n    scrollEnabled = _ref2.scrollEnabled,\n    flattenedTabWidth = _ref2.flattenedTabWidth,\n    tabWidths = _ref2.tabWidths;\n  var routes = navigationState.routes;\n  return routes.reduce(function (acc, _, i) {\n    return acc + (i > 0 ? gap != null ? gap : 0 : 0) + getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedTabWidth);\n  }, 0);\n};\nvar normalizeScrollValue = function normalizeScrollValue(_ref3) {\n  var layout = _ref3.layout,\n    navigationState = _ref3.navigationState,\n    gap = _ref3.gap,\n    scrollEnabled = _ref3.scrollEnabled,\n    tabWidths = _ref3.tabWidths,\n    value = _ref3.value,\n    flattenedTabWidth = _ref3.flattenedTabWidth;\n  var tabBarWidth = getTabBarWidth({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth\n  });\n  var maxDistance = getMaxScrollDistance(tabBarWidth, layout.width);\n  var scrollValue = Math.max(Math.min(value, maxDistance), 0);\n  if (Platform.OS === 'android' && I18nManager.isRTL) {\n    return maxDistance - scrollValue;\n  }\n  return scrollValue;\n};\nvar getScrollAmount = function getScrollAmount(_ref4) {\n  var layout = _ref4.layout,\n    navigationState = _ref4.navigationState,\n    gap = _ref4.gap,\n    scrollEnabled = _ref4.scrollEnabled,\n    flattenedTabWidth = _ref4.flattenedTabWidth,\n    tabWidths = _ref4.tabWidths;\n  var centerDistance = Array.from({\n    length: navigationState.index + 1\n  }).reduce(function (total, _, i) {\n    var tabWidth = getComputedTabWidth(i, layout, navigationState.routes, scrollEnabled, tabWidths, flattenedTabWidth);\n    return total + (navigationState.index === i ? (tabWidth + (gap != null ? gap : 0)) / 2 : tabWidth + (gap != null ? gap : 0));\n  }, 0);\n  var scrollAmount = centerDistance - layout.width / 2;\n  return normalizeScrollValue({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    value: scrollAmount,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth\n  });\n};\nvar getLabelTextDefault = function getLabelTextDefault(_ref5) {\n  var route = _ref5.route;\n  return route.title;\n};\nvar getAccessibleDefault = function getAccessibleDefault(_ref6) {\n  var route = _ref6.route;\n  return typeof route.accessible !== 'undefined' ? route.accessible : true;\n};\nvar getAccessibilityLabelDefault = function getAccessibilityLabelDefault(_ref7) {\n  var route = _ref7.route;\n  return typeof route.accessibilityLabel === 'string' ? route.accessibilityLabel : typeof route.title === 'string' ? route.title : undefined;\n};\nvar renderIndicatorDefault = function renderIndicatorDefault(props) {\n  return React.createElement(TabBarIndicator, props);\n};\nvar getTestIdDefault = function getTestIdDefault(_ref8) {\n  var route = _ref8.route;\n  return route.testID;\n};\nexport default function TabBar(_ref9) {\n  var _ref9$getLabelText = _ref9.getLabelText,\n    getLabelText = _ref9$getLabelText === void 0 ? getLabelTextDefault : _ref9$getLabelText,\n    _ref9$getAccessible = _ref9.getAccessible,\n    getAccessible = _ref9$getAccessible === void 0 ? getAccessibleDefault : _ref9$getAccessible,\n    _ref9$getAccessibilit = _ref9.getAccessibilityLabel,\n    getAccessibilityLabel = _ref9$getAccessibilit === void 0 ? getAccessibilityLabelDefault : _ref9$getAccessibilit,\n    _ref9$getTestID = _ref9.getTestID,\n    getTestID = _ref9$getTestID === void 0 ? getTestIdDefault : _ref9$getTestID,\n    _ref9$renderIndicator = _ref9.renderIndicator,\n    renderIndicator = _ref9$renderIndicator === void 0 ? renderIndicatorDefault : _ref9$renderIndicator,\n    _ref9$gap = _ref9.gap,\n    gap = _ref9$gap === void 0 ? 0 : _ref9$gap,\n    scrollEnabled = _ref9.scrollEnabled,\n    jumpTo = _ref9.jumpTo,\n    navigationState = _ref9.navigationState,\n    position = _ref9.position,\n    activeColor = _ref9.activeColor,\n    bounces = _ref9.bounces,\n    contentContainerStyle = _ref9.contentContainerStyle,\n    inactiveColor = _ref9.inactiveColor,\n    indicatorContainerStyle = _ref9.indicatorContainerStyle,\n    indicatorStyle = _ref9.indicatorStyle,\n    labelStyle = _ref9.labelStyle,\n    onTabLongPress = _ref9.onTabLongPress,\n    onTabPress = _ref9.onTabPress,\n    pressColor = _ref9.pressColor,\n    pressOpacity = _ref9.pressOpacity,\n    renderBadge = _ref9.renderBadge,\n    renderIcon = _ref9.renderIcon,\n    renderLabel = _ref9.renderLabel,\n    renderTabBarItem = _ref9.renderTabBarItem,\n    style = _ref9.style,\n    tabStyle = _ref9.tabStyle;\n  var _React$useState = React.useState({\n      width: 0,\n      height: 0\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    layout = _React$useState2[0],\n    setLayout = _React$useState2[1];\n  var _React$useState3 = React.useState({}),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    tabWidths = _React$useState4[0],\n    setTabWidths = _React$useState4[1];\n  var flatListRef = React.useRef(null);\n  var isFirst = React.useRef(true);\n  var scrollAmount = useAnimatedValue(0);\n  var measuredTabWidths = React.useRef({});\n  var routes = navigationState.routes;\n  var flattenedTabWidth = getFlattenedTabWidth(tabStyle);\n  var isWidthDynamic = flattenedTabWidth === 'auto';\n  var scrollOffset = getScrollAmount({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth\n  });\n  var hasMeasuredTabWidths = Boolean(layout.width) && routes.every(function (r) {\n    return typeof tabWidths[r.key] === 'number';\n  });\n  React.useEffect(function () {\n    if (isFirst.current) {\n      isFirst.current = false;\n      return;\n    }\n    if (isWidthDynamic && !hasMeasuredTabWidths) {\n      return;\n    }\n    if (scrollEnabled) {\n      var _flatListRef$current;\n      (_flatListRef$current = flatListRef.current) === null || _flatListRef$current === void 0 ? void 0 : _flatListRef$current.scrollToOffset({\n        offset: scrollOffset,\n        animated: true\n      });\n    }\n  }, [hasMeasuredTabWidths, isWidthDynamic, scrollEnabled, scrollOffset]);\n  var handleLayout = function handleLayout(e) {\n    var _e$nativeEvent$layout = e.nativeEvent.layout,\n      height = _e$nativeEvent$layout.height,\n      width = _e$nativeEvent$layout.width;\n    setLayout(function (layout) {\n      return layout.width === width && layout.height === height ? layout : {\n        width: width,\n        height: height\n      };\n    });\n  };\n  var tabBarWidth = getTabBarWidth({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth\n  });\n  var separatorsWidth = Math.max(0, routes.length - 1) * gap;\n  var separatorPercent = separatorsWidth / tabBarWidth * 100;\n  var tabBarWidthPercent = routes.length * 40 + \"%\";\n  var translateX = React.useMemo(function () {\n    return getTranslateX(scrollAmount, getMaxScrollDistance(tabBarWidth, layout.width));\n  }, [layout.width, scrollAmount, tabBarWidth]);\n  var renderItem = React.useCallback(function (_ref10) {\n    var route = _ref10.item,\n      index = _ref10.index;\n    var props = {\n      key: route.key,\n      position: position,\n      route: route,\n      navigationState: navigationState,\n      getAccessibilityLabel: getAccessibilityLabel,\n      getAccessible: getAccessible,\n      getLabelText: getLabelText,\n      getTestID: getTestID,\n      renderBadge: renderBadge,\n      renderIcon: renderIcon,\n      renderLabel: renderLabel,\n      activeColor: activeColor,\n      inactiveColor: inactiveColor,\n      pressColor: pressColor,\n      pressOpacity: pressOpacity,\n      onLayout: isWidthDynamic ? function (e) {\n        measuredTabWidths.current[route.key] = e.nativeEvent.layout.width;\n        if (routes.every(function (r) {\n          return typeof measuredTabWidths.current[r.key] === 'number';\n        })) {\n          setTabWidths(_objectSpread({}, measuredTabWidths.current));\n        }\n      } : undefined,\n      onPress: function onPress() {\n        var event = {\n          route: route,\n          defaultPrevented: false,\n          preventDefault: function preventDefault() {\n            event.defaultPrevented = true;\n          }\n        };\n        onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);\n        if (event.defaultPrevented) {\n          return;\n        }\n        jumpTo(route.key);\n      },\n      onLongPress: function onLongPress() {\n        return onTabLongPress === null || onTabLongPress === void 0 ? void 0 : onTabLongPress({\n          route: route\n        });\n      },\n      labelStyle: labelStyle,\n      style: tabStyle,\n      defaultTabWidth: !isWidthDynamic ? getComputedTabWidth(index, layout, routes, scrollEnabled, tabWidths, getFlattenedTabWidth(tabStyle)) : undefined\n    };\n    return React.createElement(React.Fragment, null, gap > 0 && index > 0 ? React.createElement(Separator, {\n      width: gap\n    }) : null, renderTabBarItem ? renderTabBarItem(props) : React.createElement(TabBarItem, props));\n  }, [activeColor, gap, getAccessibilityLabel, getAccessible, getLabelText, getTestID, inactiveColor, isWidthDynamic, jumpTo, labelStyle, layout, navigationState, onTabLongPress, onTabPress, position, pressColor, pressOpacity, renderBadge, renderIcon, renderLabel, renderTabBarItem, routes, scrollEnabled, tabStyle, tabWidths]);\n  var keyExtractor = React.useCallback(function (item) {\n    return item.key;\n  }, []);\n  var contentContainerStyleMemoized = React.useMemo(function () {\n    return [styles.tabContent, scrollEnabled ? {\n      width: tabBarWidth > separatorsWidth ? tabBarWidth : tabBarWidthPercent\n    } : styles.container, contentContainerStyle];\n  }, [contentContainerStyle, scrollEnabled, separatorsWidth, tabBarWidth, tabBarWidthPercent]);\n  var handleScroll = React.useMemo(function () {\n    return Animated.event([{\n      nativeEvent: {\n        contentOffset: {\n          x: scrollAmount\n        }\n      }\n    }], {\n      useNativeDriver: true\n    });\n  }, [scrollAmount]);\n  return React.createElement(Animated.View, {\n    onLayout: handleLayout,\n    style: [styles.tabBar, style]\n  }, React.createElement(Animated.View, {\n    pointerEvents: \"none\",\n    style: [styles.indicatorContainer, scrollEnabled ? {\n      transform: [{\n        translateX: translateX\n      }]\n    } : null, tabBarWidth > separatorsWidth ? {\n      width: tabBarWidth - separatorsWidth\n    } : scrollEnabled ? {\n      width: tabBarWidthPercent\n    } : null, indicatorContainerStyle]\n  }, renderIndicator({\n    position: position,\n    layout: layout,\n    navigationState: navigationState,\n    jumpTo: jumpTo,\n    width: isWidthDynamic ? 'auto' : (100 - separatorPercent) / routes.length + \"%\",\n    style: indicatorStyle,\n    getTabWidth: function getTabWidth(i) {\n      return getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedTabWidth);\n    },\n    gap: gap\n  })), React.createElement(View, {\n    style: styles.scroll\n  }, React.createElement(Animated.FlatList, {\n    data: routes,\n    keyExtractor: keyExtractor,\n    horizontal: true,\n    accessibilityRole: \"tablist\",\n    keyboardShouldPersistTaps: \"handled\",\n    scrollEnabled: scrollEnabled,\n    bounces: bounces,\n    alwaysBounceHorizontal: false,\n    scrollsToTop: false,\n    showsHorizontalScrollIndicator: false,\n    showsVerticalScrollIndicator: false,\n    automaticallyAdjustContentInsets: false,\n    overScrollMode: \"never\",\n    contentContainerStyle: contentContainerStyleMemoized,\n    scrollEventThrottle: 16,\n    renderItem: renderItem,\n    onScroll: handleScroll,\n    ref: flatListRef\n  })));\n}\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scroll: {\n    overflow: Platform.select({\n      default: 'scroll',\n      web: undefined\n    })\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0\n    },\n    zIndex: 1\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n});","map":{"version":3,"mappings":"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","names":["React","TabBarItem","TabBarIndicator","useAnimatedValue","Separator","_ref","width","View","style","getFlattenedTabWidth","tabStyle","StyleSheet","flatten","getComputedTabWidth","index","layout","routes","scrollEnabled","tabWidths","flattenedWidth","key","endsWith","parseFloat","Number","isFinite","length","getMaxScrollDistance","tabBarWidth","layoutWidth","getTranslateX","scrollAmount","maxScrollDistance","Animated","multiply","Platform","OS","I18nManager","isRTL","add","getTabBarWidth","_ref2","navigationState","gap","flattenedTabWidth","reduce","acc","_","i","normalizeScrollValue","_ref3","value","maxDistance","scrollValue","Math","max","min","getScrollAmount","_ref4","centerDistance","Array","from","total","tabWidth","getLabelTextDefault","_ref5","route","title","getAccessibleDefault","_ref6","accessible","getAccessibilityLabelDefault","_ref7","accessibilityLabel","undefined","renderIndicatorDefault","props","getTestIdDefault","_ref8","testID","TabBar","getLabelText","_ref9","getAccessible","getAccessibilityLabel","getTestID","renderIndicator","jumpTo","position","activeColor","bounces","contentContainerStyle","inactiveColor","indicatorContainerStyle","indicatorStyle","labelStyle","onTabLongPress","onTabPress","pressColor","pressOpacity","renderBadge","renderIcon","renderLabel","renderTabBarItem","useState","height","setLayout","setTabWidths","flatListRef","useRef","isFirst","measuredTabWidths","isWidthDynamic","scrollOffset","hasMeasuredTabWidths","Boolean","every","r","useEffect","current","scrollToOffset","offset","animated","handleLayout","e","nativeEvent","separatorsWidth","separatorPercent","tabBarWidthPercent","translateX","useMemo","renderItem","useCallback","_ref10","item","onLayout","onPress","event","defaultPrevented","preventDefault","onLongPress","defaultTabWidth","keyExtractor","contentContainerStyleMemoized","styles","tabContent","container","handleScroll","contentOffset","x","useNativeDriver","tabBar","pointerEvents","indicatorContainer","transform","getTabWidth","scroll","FlatList","data","horizontal","accessibilityRole","keyboardShouldPersistTaps","alwaysBounceHorizontal","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","automaticallyAdjustContentInsets","overScrollMode","scrollEventThrottle","onScroll","ref","create","flex","overflow","select","default","web","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","zIndex","flexDirection","flexWrap","top","left","right","bottom"],"sources":["TabBar.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  StyleProp,\n  ViewStyle,\n  TextStyle,\n  LayoutChangeEvent,\n  I18nManager,\n  Platform,\n  FlatList,\n  ListRenderItemInfo,\n} from 'react-native';\nimport TabBarItem, { Props as TabBarItemProps } from './TabBarItem';\nimport TabBarIndicator, { Props as IndicatorProps } from './TabBarIndicator';\nimport type {\n  Route,\n  Scene,\n  SceneRendererProps,\n  NavigationState,\n  Layout,\n  Event,\n} from './types';\nimport useAnimatedValue from './useAnimatedValue';\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  getLabelText?: (scene: Scene<T>) => string | undefined;\n  getAccessible?: (scene: Scene<T>) => boolean | undefined;\n  getAccessibilityLabel?: (scene: Scene<T>) => string | undefined;\n  getTestID?: (scene: Scene<T>) => string | undefined;\n  renderLabel?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderIcon?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderBadge?: (scene: Scene<T>) => React.ReactNode;\n  renderIndicator?: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  labelStyle?: StyleProp<TextStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n  gap?: number;\n};\n\ntype FlattenedTabWidth = string | number | undefined;\n\nconst Separator = ({ width }: { width: number }) => {\n  return <View style={{ width }} />;\n};\n\nconst getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n  const tabStyle = StyleSheet.flatten(style);\n\n  return tabStyle?.width;\n};\n\nconst getComputedTabWidth = (\n  index: number,\n  layout: Layout,\n  routes: Route[],\n  scrollEnabled: boolean | undefined,\n  tabWidths: { [key: string]: number },\n  flattenedWidth: FlattenedTabWidth\n) => {\n  if (flattenedWidth === 'auto') {\n    return tabWidths[routes[index].key] || 0;\n  }\n\n  switch (typeof flattenedWidth) {\n    case 'number':\n      return flattenedWidth;\n    case 'string':\n      if (flattenedWidth.endsWith('%')) {\n        const width = parseFloat(flattenedWidth);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n\n  if (scrollEnabled) {\n    return (layout.width / 5) * 2;\n  }\n  return layout.width / routes.length;\n};\n\nconst getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n  tabBarWidth - layoutWidth;\n\nconst getTranslateX = (\n  scrollAmount: Animated.Value,\n  maxScrollDistance: number\n) =>\n  Animated.multiply(\n    Platform.OS === 'android' && I18nManager.isRTL\n      ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1))\n      : scrollAmount,\n    I18nManager.isRTL ? 1 : -1\n  );\n\nconst getTabBarWidth = <T extends Route>({\n  navigationState,\n  layout,\n  gap,\n  scrollEnabled,\n  flattenedTabWidth,\n  tabWidths,\n}: Pick<Props<T>, 'navigationState' | 'gap' | 'layout' | 'scrollEnabled'> & {\n  tabWidths: Record<string, number>;\n  flattenedTabWidth: FlattenedTabWidth;\n}) => {\n  const { routes } = navigationState;\n\n  return routes.reduce<number>(\n    (acc, _, i) =>\n      acc +\n      (i > 0 ? gap ?? 0 : 0) +\n      getComputedTabWidth(\n        i,\n        layout,\n        routes,\n        scrollEnabled,\n        tabWidths,\n        flattenedTabWidth\n      ),\n    0\n  );\n};\n\nconst normalizeScrollValue = <T extends Route>({\n  layout,\n  navigationState,\n  gap,\n  scrollEnabled,\n  tabWidths,\n  value,\n  flattenedTabWidth,\n}: Pick<Props<T>, 'layout' | 'navigationState' | 'gap' | 'scrollEnabled'> & {\n  tabWidths: Record<string, number>;\n  value: number;\n  flattenedTabWidth: FlattenedTabWidth;\n}) => {\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n  const maxDistance = getMaxScrollDistance(tabBarWidth, layout.width);\n  const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n  if (Platform.OS === 'android' && I18nManager.isRTL) {\n    // On Android, scroll value is not applied in reverse in RTL\n    // so we need to manually adjust it to apply correct value\n    return maxDistance - scrollValue;\n  }\n\n  return scrollValue;\n};\n\nconst getScrollAmount = <T extends Route>({\n  layout,\n  navigationState,\n  gap,\n  scrollEnabled,\n  flattenedTabWidth,\n  tabWidths,\n}: Pick<Props<T>, 'layout' | 'navigationState' | 'scrollEnabled' | 'gap'> & {\n  tabWidths: Record<string, number>;\n  flattenedTabWidth: FlattenedTabWidth;\n}) => {\n  const centerDistance = Array.from({\n    length: navigationState.index + 1,\n  }).reduce<number>((total, _, i) => {\n    const tabWidth = getComputedTabWidth(\n      i,\n      layout,\n      navigationState.routes,\n      scrollEnabled,\n      tabWidths,\n      flattenedTabWidth\n    );\n\n    // To get the current index centered we adjust scroll amount by width of indexes\n    // 0 through (i - 1) and add half the width of current index i\n    return (\n      total +\n      (navigationState.index === i\n        ? (tabWidth + (gap ?? 0)) / 2\n        : tabWidth + (gap ?? 0))\n    );\n  }, 0);\n\n  const scrollAmount = centerDistance - layout.width / 2;\n\n  return normalizeScrollValue({\n    layout,\n    navigationState,\n    tabWidths,\n    value: scrollAmount,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n};\n\nconst getLabelTextDefault = ({ route }: Scene<Route>) => route.title;\n\nconst getAccessibleDefault = ({ route }: Scene<Route>) =>\n  typeof route.accessible !== 'undefined' ? route.accessible : true;\n\nconst getAccessibilityLabelDefault = ({ route }: Scene<Route>) =>\n  typeof route.accessibilityLabel === 'string'\n    ? route.accessibilityLabel\n    : typeof route.title === 'string'\n    ? route.title\n    : undefined;\n\nconst renderIndicatorDefault = (props: IndicatorProps<Route>) => (\n  <TabBarIndicator {...props} />\n);\n\nconst getTestIdDefault = ({ route }: Scene<Route>) => route.testID;\n\nexport default function TabBar<T extends Route>({\n  getLabelText = getLabelTextDefault,\n  getAccessible = getAccessibleDefault,\n  getAccessibilityLabel = getAccessibilityLabelDefault,\n  getTestID = getTestIdDefault,\n  renderIndicator = renderIndicatorDefault,\n  gap = 0,\n  scrollEnabled,\n  jumpTo,\n  navigationState,\n  position,\n  activeColor,\n  bounces,\n  contentContainerStyle,\n  inactiveColor,\n  indicatorContainerStyle,\n  indicatorStyle,\n  labelStyle,\n  onTabLongPress,\n  onTabPress,\n  pressColor,\n  pressOpacity,\n  renderBadge,\n  renderIcon,\n  renderLabel,\n  renderTabBarItem,\n  style,\n  tabStyle,\n}: Props<T>) {\n  const [layout, setLayout] = React.useState<Layout>({ width: 0, height: 0 });\n  const [tabWidths, setTabWidths] = React.useState<Record<string, number>>({});\n  const flatListRef = React.useRef<FlatList>(null);\n  const isFirst = React.useRef(true);\n  const scrollAmount = useAnimatedValue(0);\n  const measuredTabWidths = React.useRef<Record<string, number>>({});\n\n  const { routes } = navigationState;\n  const flattenedTabWidth = getFlattenedTabWidth(tabStyle);\n  const isWidthDynamic = flattenedTabWidth === 'auto';\n  const scrollOffset = getScrollAmount({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n\n  const hasMeasuredTabWidths =\n    Boolean(layout.width) &&\n    routes.every((r) => typeof tabWidths[r.key] === 'number');\n\n  React.useEffect(() => {\n    if (isFirst.current) {\n      isFirst.current = false;\n      return;\n    }\n\n    if (isWidthDynamic && !hasMeasuredTabWidths) {\n      // When tab width is dynamic, only adjust the scroll once we have all tab widths and layout\n      return;\n    }\n\n    if (scrollEnabled) {\n      flatListRef.current?.scrollToOffset({\n        offset: scrollOffset,\n        animated: true,\n      });\n    }\n  }, [hasMeasuredTabWidths, isWidthDynamic, scrollEnabled, scrollOffset]);\n\n  const handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    setLayout((layout) =>\n      layout.width === width && layout.height === height\n        ? layout\n        : { width, height }\n    );\n  };\n\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n  });\n\n  const separatorsWidth = Math.max(0, routes.length - 1) * gap;\n  const separatorPercent = (separatorsWidth / tabBarWidth) * 100;\n  const tabBarWidthPercent = `${routes.length * 40}%`;\n\n  const translateX = React.useMemo(\n    () =>\n      getTranslateX(\n        scrollAmount,\n        getMaxScrollDistance(tabBarWidth, layout.width)\n      ),\n    [layout.width, scrollAmount, tabBarWidth]\n  );\n\n  const renderItem = React.useCallback(\n    ({ item: route, index }: ListRenderItemInfo<T>) => {\n      const props: TabBarItemProps<T> & { key: string } = {\n        key: route.key,\n        position: position,\n        route: route,\n        navigationState: navigationState,\n        getAccessibilityLabel: getAccessibilityLabel,\n        getAccessible: getAccessible,\n        getLabelText: getLabelText,\n        getTestID: getTestID,\n        renderBadge: renderBadge,\n        renderIcon: renderIcon,\n        renderLabel: renderLabel,\n        activeColor: activeColor,\n        inactiveColor: inactiveColor,\n        pressColor: pressColor,\n        pressOpacity: pressOpacity,\n        onLayout: isWidthDynamic\n          ? (e: LayoutChangeEvent) => {\n              measuredTabWidths.current[route.key] = e.nativeEvent.layout.width;\n\n              // When we have measured widths for all of the tabs, we should updates the state\n              // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n              if (\n                routes.every(\n                  (r) => typeof measuredTabWidths.current[r.key] === 'number'\n                )\n              ) {\n                setTabWidths({ ...measuredTabWidths.current });\n              }\n            }\n          : undefined,\n        onPress: () => {\n          const event: Scene<T> & Event = {\n            route,\n            defaultPrevented: false,\n            preventDefault: () => {\n              event.defaultPrevented = true;\n            },\n          };\n\n          onTabPress?.(event);\n\n          if (event.defaultPrevented) {\n            return;\n          }\n\n          jumpTo(route.key);\n        },\n        onLongPress: () => onTabLongPress?.({ route }),\n        labelStyle: labelStyle,\n        style: tabStyle,\n        // Calculate the deafult width for tab for FlatList to work\n        defaultTabWidth: !isWidthDynamic\n          ? getComputedTabWidth(\n              index,\n              layout,\n              routes,\n              scrollEnabled,\n              tabWidths,\n              getFlattenedTabWidth(tabStyle)\n            )\n          : undefined,\n      };\n\n      return (\n        <>\n          {gap > 0 && index > 0 ? <Separator width={gap} /> : null}\n          {renderTabBarItem ? (\n            renderTabBarItem(props)\n          ) : (\n            <TabBarItem {...props} />\n          )}\n        </>\n      );\n    },\n    [\n      activeColor,\n      gap,\n      getAccessibilityLabel,\n      getAccessible,\n      getLabelText,\n      getTestID,\n      inactiveColor,\n      isWidthDynamic,\n      jumpTo,\n      labelStyle,\n      layout,\n      navigationState,\n      onTabLongPress,\n      onTabPress,\n      position,\n      pressColor,\n      pressOpacity,\n      renderBadge,\n      renderIcon,\n      renderLabel,\n      renderTabBarItem,\n      routes,\n      scrollEnabled,\n      tabStyle,\n      tabWidths,\n    ]\n  );\n\n  const keyExtractor = React.useCallback((item: T) => item.key, []);\n\n  const contentContainerStyleMemoized = React.useMemo(\n    () => [\n      styles.tabContent,\n      scrollEnabled\n        ? {\n            width:\n              tabBarWidth > separatorsWidth ? tabBarWidth : tabBarWidthPercent,\n          }\n        : styles.container,\n      contentContainerStyle,\n    ],\n    [\n      contentContainerStyle,\n      scrollEnabled,\n      separatorsWidth,\n      tabBarWidth,\n      tabBarWidthPercent,\n    ]\n  );\n\n  const handleScroll = React.useMemo(\n    () =>\n      Animated.event(\n        [\n          {\n            nativeEvent: {\n              contentOffset: { x: scrollAmount },\n            },\n          },\n        ],\n        { useNativeDriver: true }\n      ),\n    [scrollAmount]\n  );\n\n  return (\n    <Animated.View onLayout={handleLayout} style={[styles.tabBar, style]}>\n      <Animated.View\n        pointerEvents=\"none\"\n        style={[\n          styles.indicatorContainer,\n          scrollEnabled ? { transform: [{ translateX }] as any } : null,\n          tabBarWidth > separatorsWidth\n            ? { width: tabBarWidth - separatorsWidth }\n            : scrollEnabled\n            ? { width: tabBarWidthPercent }\n            : null,\n          indicatorContainerStyle,\n        ]}\n      >\n        {renderIndicator({\n          position,\n          layout,\n          navigationState,\n          jumpTo,\n          width: isWidthDynamic\n            ? 'auto'\n            : `${(100 - separatorPercent) / routes.length}%`,\n          style: indicatorStyle,\n          getTabWidth: (i: number) =>\n            getComputedTabWidth(\n              i,\n              layout,\n              routes,\n              scrollEnabled,\n              tabWidths,\n              flattenedTabWidth\n            ),\n          gap,\n        })}\n      </Animated.View>\n      <View style={styles.scroll}>\n        <Animated.FlatList\n          data={routes as Animated.WithAnimatedValue<T>[]}\n          keyExtractor={keyExtractor}\n          horizontal\n          accessibilityRole=\"tablist\"\n          keyboardShouldPersistTaps=\"handled\"\n          scrollEnabled={scrollEnabled}\n          bounces={bounces}\n          alwaysBounceHorizontal={false}\n          scrollsToTop={false}\n          showsHorizontalScrollIndicator={false}\n          showsVerticalScrollIndicator={false}\n          automaticallyAdjustContentInsets={false}\n          overScrollMode=\"never\"\n          contentContainerStyle={contentContainerStyleMemoized}\n          scrollEventThrottle={16}\n          renderItem={renderItem}\n          onScroll={handleScroll}\n          ref={flatListRef}\n        />\n      </View>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.select({ default: 'scroll', web: undefined }),\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0,\n    },\n    zIndex: 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}